fn main() {}

// mod witness {
//     const SIGNATURES_2_OF_3: [Option<[u8; 64]>; 3] = [
//         Some(0x0a37553c24792cf29bf2c4d4f48aa45d1c0a347f07463b422e819772411d359d2ba60a92e37fdbe1f45468420c0373671e89f1c9a2714a2d7b0264adc864a7f9),
//         None,
//         Some(0x1ebdf39c4a76a566673d3fb194f185d193885e5eaadc14f32595b8ebc16fc7d9fccc9151a4d8d03cca2ef0addc5fc3ee4871f8c1a782acce5ad85a5bb425a80b)
//     ];
// }

// mod param {
//     const ALICE_PUBLIC_KEY: u256 = 0x9bef8d556d80e43ae7e0becb3a7e6838b95defe45896ed6075bb9035d06c9964;
//     const BOB_PUBLIC_KEY: u256   = 0xe37d58a1aae4ba059fd2503712d998470d3a2522f7e2335f544ef384d2199e02;
//     const CHARLIE_PUBLIC_KEY: u256 = 0x688466442a134ee312299bafb37058e385c98dd6005eaaf0f538f533efe5f91f;
// }

// fn not(bit: bool) -> bool {
//     <u1>::into(jet::complement_1(<bool>::into(bit)))
// }

// fn checksig(pk: Pubkey, sig: Signature) {
//     let msg: u256 = jet::sig_all_hash();
//     jet::bip_0340_verify((pk, msg), sig);
// }

// fn checksig_add(counter: u8, pk: Pubkey, maybe_sig: Option<Signature>) -> u8 {
//     match maybe_sig {
//         Some(sig: Signature) => {
//             checksig(pk, sig);
//             let (carry, new_counter): (bool, u8) = jet::increment_8(counter);
//             assert!(not(carry));
//             new_counter
//         }
//         None => counter,
//     }
// }

// // Enforce the covenant to repeat in the first output.
// // Elements has explicit fee outputs, so enforce a fee output in the second output.
// // Disallow further outputs.
// fn recursive_covenant() {
//     assert!(jet::eq_32(jet::num_outputs(), 2));
//     let this_script_hash: u256 = jet::current_script_hash();
//     let output_script_hash: u256 = unwrap(jet::output_script_hash(0));
//     assert!(jet::eq_256(this_script_hash, output_script_hash));
//     assert!(unwrap(jet::output_is_fee(1)));
// }

// fn check2of3multisig(pks: [Pubkey; 3], maybe_sigs: [Option<Signature>; 3]) {
//     let [pk1, pk2, pk3]: [Pubkey; 3] = pks;
//     let [sig1, sig2, sig3]: [Option<Signature>; 3] = maybe_sigs;

//     // Handle two paths using match on sig3 (no if):
//     match sig3 {
//         // Branch where Charlie's signature is present -> we verify it and then enforce recursion.
//         Some(s3: Signature) => {
//             // verify pk1 and pk2 if present
//             let counter1: u8 = checksig_add(0, pk1, sig1);
//             let counter2: u8 = checksig_add(counter1, pk2, sig2);
//             // verify pk3 (Charlie) and increment
//             let counter3: u8 = checksig_add(counter2, pk3, Some(s3));
//             let threshold: u8 = 2;
//             assert!(jet::eq_8(counter3, threshold));
//             // because we're in the Some(s3) branch, Charlie participated â€” enforce recursion
//             recursive_covenant();
//         }
//         // Branch where Charlie's signature is absent -> verify only pk1/pk2 and do NOT recurse.
//         None => {
//             let counter1: u8 = checksig_add(0, pk1, sig1);
//             let counter2: u8 = checksig_add(counter1, pk2, sig2);
//             // no checksig_add for pk3 (no signature)
//             let counter3: u8 = counter2;
//             let threshold: u8 = 2;
//             assert!(jet::eq_8(counter3, threshold));
//             // no recursive_covenant() call here
//         }
//     }
// }

// fn main() {
//     let pks: [Pubkey; 3] = [
//         param::ALICE_PUBLIC_KEY,
//         param::BOB_PUBLIC_KEY,
//         param::CHARLIE_PUBLIC_KEY,
//     ];
//     check2of3multisig(pks, witness::SIGNATURES_2_OF_3);
// }
// /*
//  * LAST WILL
//  *
//  * The inheritor can spend the coins if the owner doesn't move the them for 180
//  * days. The owner has to repeat the covenant when he moves the coins with his
//  * hot key. The owner can break out of the covenant with his cold key.
//  */
// fn checksig(pk: Pubkey, sig: Signature) {
//     let msg: u256 = jet::sig_all_hash();
//     jet::bip_0340_verify((pk, msg), sig);
// }

// // Enforce the covenant to repeat in the first output.
// //
// // Elements has explicit fee outputs, so enforce a fee output in the second output.
// // Disallow further outputs.
// fn recursive_covenant() {
//     assert!(jet::eq_32(jet::num_outputs(), 2));
//     let this_script_hash: u256 = jet::current_script_hash();
//     let output_script_hash: u256 = unwrap(jet::output_script_hash(0));
//     assert!(jet::eq_256(this_script_hash, output_script_hash));
//     assert!(unwrap(jet::output_is_fee(1)));
// }

// fn inherit_spend(inheritor_sig: Signature) {
//     let days_180: Distance = 25920;
//     jet::check_lock_distance(days_180);
//     let inheritor_pk: Pubkey = 0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798; // 1 * G
//     checksig(inheritor_pk, inheritor_sig);
// }

// fn cold_spend(cold_sig: Signature) {
//     let cold_pk: Pubkey = 0xc6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5; // 2 * G
//     checksig(cold_pk, cold_sig);
// }

// fn refresh_spend(hot_sig: Signature) {
//     let hot_pk: Pubkey = 0xf9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9; // 3 * G
//     checksig(hot_pk, hot_sig);
//     recursive_covenant();
// }

// fn main() {
//     match witness::INHERIT_OR_NOT {
//         Left(inheritor_sig: Signature) => inherit_spend(inheritor_sig),
//         Right(cold_or_hot: Either<Signature, Signature>) => match cold_or_hot {
//             Left(cold_sig: Signature) => cold_spend(cold_sig),
//             Right(hot_sig: Signature) => refresh_spend(hot_sig),
//         },
//     }
// }



// who spends:
// - event attendee
// - event owner
// - evnet 

